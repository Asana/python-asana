# coding: utf-8

"""
    Asana

    This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from asana.api_client import ApiClient


class TasksApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_dependencies_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Set dependencies for a task  # noqa: E501

        Marks a set of tasks as dependencies of this task, if they are not already dependencies. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dependencies_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddDependenciesBody body: The list of tasks to set as dependencies. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.add_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def add_dependencies_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Set dependencies for a task  # noqa: E501

        Marks a set of tasks as dependencies of this task, if they are not already dependencies. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dependencies_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddDependenciesBody body: The list of tasks to set as dependencies. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dependencies_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_dependencies_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `add_dependencies_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/addDependencies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dependents_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Set dependents for a task  # noqa: E501

        Marks a set of tasks as dependents of this task, if they are not already dependents. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dependents_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddDependentsBody body: The list of tasks to add as dependents. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.add_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def add_dependents_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Set dependents for a task  # noqa: E501

        Marks a set of tasks as dependents of this task, if they are not already dependents. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dependents_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddDependentsBody body: The list of tasks to add as dependents. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dependents_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_dependents_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `add_dependents_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/addDependents', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_followers_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Add followers to a task  # noqa: E501

        Adds followers to a task. Returns an empty data block. Each task can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated task record, described above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_followers_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddFollowersBody body: The followers to add to the task. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.add_followers_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.add_followers_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def add_followers_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Add followers to a task  # noqa: E501

        Adds followers to a task. Returns an empty data block. Each task can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated task record, described above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_followers_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddFollowersBody body: The followers to add to the task. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_followers_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_followers_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `add_followers_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/addFollowers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_project_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Add a project to a task  # noqa: E501

        Adds the task to the specified project, in the optional location specified. If no location arguments are given, the task will be added to the end of the project.  `addProject` can also be used to reorder a task within a project or section that already contains it.  At most one of `insert_before`, `insert_after`, or `section` should be specified. Inserting into a section in an non-order-dependent way can be done by specifying section, otherwise, to insert within a section in a particular place, specify `insert_before` or `insert_after` and a task within the section to anchor the position of this task.  Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_project_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddProjectBody body: The project to add the task to. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.add_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.add_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def add_project_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Add a project to a task  # noqa: E501

        Adds the task to the specified project, in the optional location specified. If no location arguments are given, the task will be added to the end of the project.  `addProject` can also be used to reorder a task within a project or section that already contains it.  At most one of `insert_before`, `insert_after`, or `section` should be specified. Inserting into a section in an non-order-dependent way can be done by specifying section, otherwise, to insert within a section in a particular place, specify `insert_before` or `insert_after` and a task within the section to anchor the position of this task.  Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_project_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddProjectBody body: The project to add the task to. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_project_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_project_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `add_project_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/addProject', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_tag_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Add a tag to a task  # noqa: E501

        Adds a tag to a task. Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_tag_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddTagBody body: The tag to add to the task. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.add_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.add_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def add_tag_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Add a tag to a task  # noqa: E501

        Adds a tag to a task. Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_tag_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidAddTagBody body: The tag to add to the task. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_tag_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_tag_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `add_tag_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/addTag', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_subtask_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Create a subtask  # noqa: E501

        Creates a new subtask and adds it to the parent task. Returns the full record for the newly created subtask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_subtask_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidSubtasksBody body: The new subtask to create. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.create_subtask_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.create_subtask_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def create_subtask_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Create a subtask  # noqa: E501

        Creates a new subtask and adds it to the parent task. Returns the full record for the newly created subtask.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_subtask_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidSubtasksBody body: The new subtask to create. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_subtask_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_subtask_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `create_subtask_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/subtasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task(self, body, **kwargs):  # noqa: E501
        """Create a task  # noqa: E501

        Creating a new task is as easy as POSTing to the `/tasks` endpoint with a data block containing the fields you’d like to set on the task. Any unspecified fields will take on default values.  Every task is required to be created in a specific workspace, and this workspace cannot be changed once set. The workspace need not be set explicitly if you specify `projects` or a `parent` task instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TasksBody body: The task to create. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.create_task_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_task_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_task_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a task  # noqa: E501

        Creating a new task is as easy as POSTing to the `/tasks` endpoint with a data block containing the fields you’d like to set on the task. Any unspecified fields will take on default values.  Every task is required to be created in a specific workspace, and this workspace cannot be changed once set. The workspace need not be set explicitly if you specify `projects` or a `parent` task instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TasksBody body: The task to create. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_task(self, task_gid, **kwargs):  # noqa: E501
        """Delete a task  # noqa: E501

        A specific, existing task can be deleted by making a DELETE request on the URL for that task. Deleted tasks go into the “trash” of the user making the delete request. Tasks can be recovered from the trash within a period of 30 days; afterward they are completely removed from the system.  Returns an empty data record.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_task(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.delete_task_with_http_info(task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_task_with_http_info(task_gid, **kwargs)  # noqa: E501
            return data

    def delete_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
        """Delete a task  # noqa: E501

        A specific, existing task can be deleted by making a DELETE request on the URL for that task. Deleted tasks go into the “trash” of the user making the delete request. Tasks can be recovered from the trash within a period of 30 days; afterward they are completely removed from the system.  Returns an empty data record.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_task_with_http_info(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `delete_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def duplicate_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Duplicate a task  # noqa: E501

        Creates and returns a job that will asynchronously handle the duplication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidDuplicateBody body: Describes the duplicate's name and the fields that will be duplicated. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: JobResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.duplicate_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.duplicate_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def duplicate_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Duplicate a task  # noqa: E501

        Creates and returns a job that will asynchronously handle the duplication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.duplicate_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidDuplicateBody body: Describes the duplicate's name and the fields that will be duplicated. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: JobResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method duplicate_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `duplicate_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `duplicate_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/duplicate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dependencies_for_task(self, task_gid, **kwargs):  # noqa: E501
        """Get dependencies from a task  # noqa: E501

        Returns the compact representations of all of the dependencies of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dependencies_for_task(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_dependencies_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dependencies_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
            return data

    def get_dependencies_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
        """Get dependencies from a task  # noqa: E501

        Returns the compact representations of all of the dependencies of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dependencies_for_task_with_http_info(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dependencies_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `get_dependencies_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/dependencies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dependents_for_task(self, task_gid, **kwargs):  # noqa: E501
        """Get dependents from a task  # noqa: E501

        Returns the compact representations of all of the dependents of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dependents_for_task(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_dependents_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dependents_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
            return data

    def get_dependents_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
        """Get dependents from a task  # noqa: E501

        Returns the compact representations of all of the dependents of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dependents_for_task_with_http_info(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dependents_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `get_dependents_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/dependents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_subtasks_for_task(self, task_gid, **kwargs):  # noqa: E501
        """Get subtasks from a task  # noqa: E501

        Returns a compact representation of all of the subtasks of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subtasks_for_task(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_subtasks_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subtasks_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
            return data

    def get_subtasks_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
        """Get subtasks from a task  # noqa: E501

        Returns a compact representation of all of the subtasks of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subtasks_for_task_with_http_info(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subtasks_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `get_subtasks_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/subtasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task(self, task_gid, **kwargs):  # noqa: E501
        """Get a task  # noqa: E501

        Returns the complete task record for a single task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_task_with_http_info(task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_task_with_http_info(task_gid, **kwargs)  # noqa: E501
            return data

    def get_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
        """Get a task  # noqa: E501

        Returns the complete task record for a single task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_with_http_info(task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_gid', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `get_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks(self, **kwargs):  # noqa: E501
        """Get multiple tasks  # noqa: E501

        Returns the compact task records for some filtered set of tasks. Use one or more of the parameters provided to filter the tasks returned. You must specify a `project` or `tag` if you do not specify `assignee` and `workspace`.  For more complex task retrieval, use [workspaces/{workspace_gid}/tasks/search](/reference/searchtasksforworkspace).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param str assignee: The assignee to filter tasks on. If searching for unassigned tasks, assignee.any = null can be specified. *Note: If you specify `assignee`, you must also specify the `workspace` to filter on.*
        :param str project: The project to filter tasks on.
        :param str section: The section to filter tasks on.
        :param str workspace: The workspace to filter tasks on. *Note: If you specify `workspace`, you must also specify the `assignee` to filter on.*
        :param datetime completed_since: Only return tasks that are either incomplete or that have been completed since this time.
        :param datetime modified_since: Only return tasks that have been modified since the given time.  *Note: A task is considered “modified” if any of its properties change, or associations between it and other objects are modified (e.g.  a task being added to a project). A task is not considered modified just because another object it is associated with (e.g. a subtask) is modified. Actions that count as modifying the task include assigning, renaming, completing, and adding stories.*
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_tasks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_tasks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_tasks_with_http_info(self, **kwargs):  # noqa: E501
        """Get multiple tasks  # noqa: E501

        Returns the compact task records for some filtered set of tasks. Use one or more of the parameters provided to filter the tasks returned. You must specify a `project` or `tag` if you do not specify `assignee` and `workspace`.  For more complex task retrieval, use [workspaces/{workspace_gid}/tasks/search](/reference/searchtasksforworkspace).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param str assignee: The assignee to filter tasks on. If searching for unassigned tasks, assignee.any = null can be specified. *Note: If you specify `assignee`, you must also specify the `workspace` to filter on.*
        :param str project: The project to filter tasks on.
        :param str section: The section to filter tasks on.
        :param str workspace: The workspace to filter tasks on. *Note: If you specify `workspace`, you must also specify the `assignee` to filter on.*
        :param datetime completed_since: Only return tasks that are either incomplete or that have been completed since this time.
        :param datetime modified_since: Only return tasks that have been modified since the given time.  *Note: A task is considered “modified” if any of its properties change, or associations between it and other objects are modified (e.g.  a task being added to a project). A task is not considered modified just because another object it is associated with (e.g. a subtask) is modified. Actions that count as modifying the task include assigning, renaming, completing, and adding stories.*
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset', 'assignee', 'project', 'section', 'workspace', 'completed_since', 'modified_since', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'assignee' in params:
            query_params.append(('assignee', params['assignee']))  # noqa: E501
        if 'project' in params:
            query_params.append(('project', params['project']))  # noqa: E501
        if 'section' in params:
            query_params.append(('section', params['section']))  # noqa: E501
        if 'workspace' in params:
            query_params.append(('workspace', params['workspace']))  # noqa: E501
        if 'completed_since' in params:
            query_params.append(('completed_since', params['completed_since']))  # noqa: E501
        if 'modified_since' in params:
            query_params.append(('modified_since', params['modified_since']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_for_project(self, project_gid, **kwargs):  # noqa: E501
        """Get tasks from a project  # noqa: E501

        Returns the compact task records for all tasks within the given project, ordered by their priority within the project. Tasks can exist in more than one project at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_project(project_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_gid: Globally unique identifier for the project. (required)
        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_tasks_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tasks_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
            return data

    def get_tasks_for_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
        """Get tasks from a project  # noqa: E501

        Returns the compact task records for all tasks within the given project, ordered by their priority within the project. Tasks can exist in more than one project at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_project_with_http_info(project_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_gid: Globally unique identifier for the project. (required)
        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_gid', 'completed_since', 'limit', 'offset', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_for_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_gid' is set
        if ('project_gid' not in params or
                params['project_gid'] is None):
            raise ValueError("Missing the required parameter `project_gid` when calling `get_tasks_for_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_gid' in params:
            path_params['project_gid'] = params['project_gid']  # noqa: E501

        query_params = []
        if 'completed_since' in params:
            query_params.append(('completed_since', params['completed_since']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_gid}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_for_section(self, section_gid, **kwargs):  # noqa: E501
        """Get tasks from a section  # noqa: E501

        *Board view only*: Returns the compact section records for all tasks within the given section.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_section(section_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_gid: The globally unique identifier for the section. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_tasks_for_section_with_http_info(section_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tasks_for_section_with_http_info(section_gid, **kwargs)  # noqa: E501
            return data

    def get_tasks_for_section_with_http_info(self, section_gid, **kwargs):  # noqa: E501
        """Get tasks from a section  # noqa: E501

        *Board view only*: Returns the compact section records for all tasks within the given section.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_section_with_http_info(section_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str section_gid: The globally unique identifier for the section. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['section_gid', 'limit', 'offset', 'completed_since', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_for_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'section_gid' is set
        if ('section_gid' not in params or
                params['section_gid'] is None):
            raise ValueError("Missing the required parameter `section_gid` when calling `get_tasks_for_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'section_gid' in params:
            path_params['section_gid'] = params['section_gid']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'completed_since' in params:
            query_params.append(('completed_since', params['completed_since']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/sections/{section_gid}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_for_tag(self, tag_gid, **kwargs):  # noqa: E501
        """Get tasks from a tag  # noqa: E501

        Returns the compact task records for all tasks with the given tag. Tasks can have more than one tag at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_tag(tag_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_gid: Globally unique identifier for the tag. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_tasks_for_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tasks_for_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
            return data

    def get_tasks_for_tag_with_http_info(self, tag_gid, **kwargs):  # noqa: E501
        """Get tasks from a tag  # noqa: E501

        Returns the compact task records for all tasks with the given tag. Tasks can have more than one tag at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_tag_with_http_info(tag_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_gid: Globally unique identifier for the tag. (required)
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_for_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tag_gid' is set
        if ('tag_gid' not in params or
                params['tag_gid'] is None):
            raise ValueError("Missing the required parameter `tag_gid` when calling `get_tasks_for_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tag_gid' in params:
            path_params['tag_gid'] = params['tag_gid']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tags/{tag_gid}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_for_user_task_list(self, user_task_list_gid, **kwargs):  # noqa: E501
        """Get tasks from a user task list  # noqa: E501

        Returns the compact list of tasks in a user’s My Tasks list. *Note: Access control is enforced for this endpoint as with all Asana API endpoints, meaning a user’s private tasks will be filtered out if the API-authenticated user does not have access to them.* *Note: Both complete and incomplete tasks are returned by default unless they are filtered out (for example, setting `completed_since=now` will return only incomplete tasks, which is the default view for “My Tasks” in Asana.)*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_user_task_list(user_task_list_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_task_list_gid: Globally unique identifier for the user task list. (required)
        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, **kwargs)  # noqa: E501
            return data

    def get_tasks_for_user_task_list_with_http_info(self, user_task_list_gid, **kwargs):  # noqa: E501
        """Get tasks from a user task list  # noqa: E501

        Returns the compact list of tasks in a user’s My Tasks list. *Note: Access control is enforced for this endpoint as with all Asana API endpoints, meaning a user’s private tasks will be filtered out if the API-authenticated user does not have access to them.* *Note: Both complete and incomplete tasks are returned by default unless they are filtered out (for example, setting `completed_since=now` will return only incomplete tasks, which is the default view for “My Tasks” in Asana.)*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_task_list_gid: Globally unique identifier for the user task list. (required)
        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_task_list_gid', 'completed_since', 'limit', 'offset', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_for_user_task_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_task_list_gid' is set
        if ('user_task_list_gid' not in params or
                params['user_task_list_gid'] is None):
            raise ValueError("Missing the required parameter `user_task_list_gid` when calling `get_tasks_for_user_task_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_task_list_gid' in params:
            path_params['user_task_list_gid'] = params['user_task_list_gid']  # noqa: E501

        query_params = []
        if 'completed_since' in params:
            query_params.append(('completed_since', params['completed_since']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/user_task_lists/{user_task_list_gid}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_dependencies_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Unlink dependencies from a task  # noqa: E501

        Unlinks a set of dependencies from this task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_dependencies_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveDependenciesBody body: The list of tasks to unlink as dependencies. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.remove_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def remove_dependencies_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Unlink dependencies from a task  # noqa: E501

        Unlinks a set of dependencies from this task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_dependencies_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveDependenciesBody body: The list of tasks to unlink as dependencies. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_dependencies_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_dependencies_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `remove_dependencies_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/removeDependencies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_dependents_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Unlink dependents from a task  # noqa: E501

        Unlinks a set of dependents from this task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_dependents_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveDependentsBody body: The list of tasks to remove as dependents. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.remove_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def remove_dependents_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Unlink dependents from a task  # noqa: E501

        Unlinks a set of dependents from this task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_dependents_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveDependentsBody body: The list of tasks to remove as dependents. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_dependents_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_dependents_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `remove_dependents_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/removeDependents', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_follower_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Remove followers from a task  # noqa: E501

        Removes each of the specified followers from the task if they are following. Returns the complete, updated record for the affected task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_follower_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveFollowersBody body: The followers to remove from the task. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.remove_follower_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_follower_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def remove_follower_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Remove followers from a task  # noqa: E501

        Removes each of the specified followers from the task if they are following. Returns the complete, updated record for the affected task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_follower_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveFollowersBody body: The followers to remove from the task. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_follower_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_follower_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `remove_follower_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/removeFollowers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_project_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Remove a project from a task  # noqa: E501

        Removes the task from the specified project. The task will still exist in the system, but it will not be in the project anymore.  Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_project_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveProjectBody body: The project to remove the task from. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.remove_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def remove_project_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Remove a project from a task  # noqa: E501

        Removes the task from the specified project. The task will still exist in the system, but it will not be in the project anymore.  Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_project_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveProjectBody body: The project to remove the task from. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_project_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_project_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `remove_project_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/removeProject', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_tag_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Remove a tag from a task  # noqa: E501

        Removes a tag from a task. Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_tag_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveTagBody body: The tag to remove from the task. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.remove_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def remove_tag_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Remove a tag from a task  # noqa: E501

        Removes a tag from a task. Returns an empty data block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_tag_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidRemoveTagBody body: The tag to remove from the task. (required)
        :param str task_gid: The task to operate on. (required)
        :return: EmptyResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_tag_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_tag_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `remove_tag_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/removeTag', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_tasks_for_workspace(self, workspace_gid, **kwargs):  # noqa: E501
        """Search tasks in a workspace  # noqa: E501

        To mirror the functionality of the Asana web app's advanced search feature, the Asana API has a task search endpoint that allows you to build complex filters to find and retrieve the exact data you need. #### Premium access Like the Asana web product's advance search feature, this search endpoint will only be available to premium Asana users. A user is premium if any of the following is true:  - The workspace in which the search is being performed is a premium workspace - The user is a member of a premium team inside the workspace  Even if a user is only a member of a premium team inside a non-premium workspace, search will allow them to find data anywhere in the workspace, not just inside the premium team. Making a search request using credentials of a non-premium user will result in a `402 Payment Required` error. #### Pagination Search results are not stable; repeating the same query multiple times may return the data in a different order, even if the data do not change. Because of this, the traditional [pagination](https://developers.asana.com/docs/#pagination) available elsewhere in the Asana API is not available here. However, you can paginate manually by sorting the search results by their creation time and then modifying each subsequent query to exclude data you have already seen. Page sizes are limited to a maximum of 100 items, and can be specified by the `limit` query parameter. #### Eventual consistency Changes in Asana (regardless of whether they’re made though the web product or the API) are forwarded to our search infrastructure to be indexed. This process can take between 10 and 60 seconds to complete under normal operation, and longer during some production incidents. Making a change to a task that would alter its presence in a particular search query will not be reflected immediately. This is also true of the advanced search feature in the web product. #### Rate limits You may receive a `429 Too Many Requests` response if you hit any of our [rate limits](https://developers.asana.com/docs/#rate-limits). #### Custom field parameters | Parameter name | Custom field type | Accepted type | |---|---|---| | custom_fields.{gid}.is_set | All | Boolean | | custom_fields.{gid}.value | Text | String | | custom_fields.{gid}.value | Number | Number | | custom_fields.{gid}.value | Enum | Enum option ID | | custom_fields.{gid}.starts_with | Text only | String | | custom_fields.{gid}.ends_with | Text only | String | | custom_fields.{gid}.contains | Text only | String | | custom_fields.{gid}.less_than | Number only | Number | | custom_fields.{gid}.greater_than | Number only | Number |   For example, if the gid of the custom field is 12345, these query parameter to find tasks where it is set would be `custom_fields.12345.is_set=true`. To match an exact value for an enum custom field, use the gid of the desired enum option and not the name of the enum option: `custom_fields.12345.value=67890`.  **Not Supported**: searching for multiple exact matches of a custom field, searching for multi-enum custom field  *Note: If you specify `projects.any` and `sections.any`, you will receive tasks for the project **and** tasks for the section. If you're looking for only tasks in a section, omit the `projects.any` from the request.*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tasks_for_workspace(workspace_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
        :param str text: Performs full-text search on both task name and description
        :param str resource_subtype: Filters results by the task's resource_subtype
        :param str assignee_any: Comma-separated list of user identifiers
        :param str assignee_not: Comma-separated list of user identifiers
        :param str portfolios_any: Comma-separated list of portfolio IDs
        :param str projects_any: Comma-separated list of project IDs
        :param str projects_not: Comma-separated list of project IDs
        :param str projects_all: Comma-separated list of project IDs
        :param str sections_any: Comma-separated list of section or column IDs
        :param str sections_not: Comma-separated list of section or column IDs
        :param str sections_all: Comma-separated list of section or column IDs
        :param str tags_any: Comma-separated list of tag IDs
        :param str tags_not: Comma-separated list of tag IDs
        :param str tags_all: Comma-separated list of tag IDs
        :param str teams_any: Comma-separated list of team IDs
        :param str followers_not: Comma-separated list of user identifiers
        :param str created_by_any: Comma-separated list of user identifiers
        :param str created_by_not: Comma-separated list of user identifiers
        :param str assigned_by_any: Comma-separated list of user identifiers
        :param str assigned_by_not: Comma-separated list of user identifiers
        :param str liked_by_not: Comma-separated list of user identifiers
        :param str commented_on_by_not: Comma-separated list of user identifiers
        :param date due_on_before: ISO 8601 date string
        :param date due_on_after: ISO 8601 date string
        :param date due_on: ISO 8601 date string or `null`
        :param datetime due_at_before: ISO 8601 datetime string
        :param datetime due_at_after: ISO 8601 datetime string
        :param date start_on_before: ISO 8601 date string
        :param date start_on_after: ISO 8601 date string
        :param date start_on: ISO 8601 date string or `null`
        :param date created_on_before: ISO 8601 date string
        :param date created_on_after: ISO 8601 date string
        :param date created_on: ISO 8601 date string or `null`
        :param datetime created_at_before: ISO 8601 datetime string
        :param datetime created_at_after: ISO 8601 datetime string
        :param date completed_on_before: ISO 8601 date string
        :param date completed_on_after: ISO 8601 date string
        :param date completed_on: ISO 8601 date string or `null`
        :param datetime completed_at_before: ISO 8601 datetime string
        :param datetime completed_at_after: ISO 8601 datetime string
        :param date modified_on_before: ISO 8601 date string
        :param date modified_on_after: ISO 8601 date string
        :param date modified_on: ISO 8601 date string or `null`
        :param datetime modified_at_before: ISO 8601 datetime string
        :param datetime modified_at_after: ISO 8601 datetime string
        :param bool is_blocking: Filter to incomplete tasks with dependents
        :param bool is_blocked: Filter to tasks with incomplete dependencies
        :param bool has_attachment: Filter to tasks with attachments
        :param bool completed: Filter to completed tasks
        :param bool is_subtask: Filter to subtasks
        :param str sort_by: One of `due_date`, `created_at`, `completed_at`, `likes`, or `modified_at`, defaults to `modified_at`
        :param bool sort_ascending: Default `false`
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.search_tasks_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.search_tasks_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
            return data

    def search_tasks_for_workspace_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
        """Search tasks in a workspace  # noqa: E501

        To mirror the functionality of the Asana web app's advanced search feature, the Asana API has a task search endpoint that allows you to build complex filters to find and retrieve the exact data you need. #### Premium access Like the Asana web product's advance search feature, this search endpoint will only be available to premium Asana users. A user is premium if any of the following is true:  - The workspace in which the search is being performed is a premium workspace - The user is a member of a premium team inside the workspace  Even if a user is only a member of a premium team inside a non-premium workspace, search will allow them to find data anywhere in the workspace, not just inside the premium team. Making a search request using credentials of a non-premium user will result in a `402 Payment Required` error. #### Pagination Search results are not stable; repeating the same query multiple times may return the data in a different order, even if the data do not change. Because of this, the traditional [pagination](https://developers.asana.com/docs/#pagination) available elsewhere in the Asana API is not available here. However, you can paginate manually by sorting the search results by their creation time and then modifying each subsequent query to exclude data you have already seen. Page sizes are limited to a maximum of 100 items, and can be specified by the `limit` query parameter. #### Eventual consistency Changes in Asana (regardless of whether they’re made though the web product or the API) are forwarded to our search infrastructure to be indexed. This process can take between 10 and 60 seconds to complete under normal operation, and longer during some production incidents. Making a change to a task that would alter its presence in a particular search query will not be reflected immediately. This is also true of the advanced search feature in the web product. #### Rate limits You may receive a `429 Too Many Requests` response if you hit any of our [rate limits](https://developers.asana.com/docs/#rate-limits). #### Custom field parameters | Parameter name | Custom field type | Accepted type | |---|---|---| | custom_fields.{gid}.is_set | All | Boolean | | custom_fields.{gid}.value | Text | String | | custom_fields.{gid}.value | Number | Number | | custom_fields.{gid}.value | Enum | Enum option ID | | custom_fields.{gid}.starts_with | Text only | String | | custom_fields.{gid}.ends_with | Text only | String | | custom_fields.{gid}.contains | Text only | String | | custom_fields.{gid}.less_than | Number only | Number | | custom_fields.{gid}.greater_than | Number only | Number |   For example, if the gid of the custom field is 12345, these query parameter to find tasks where it is set would be `custom_fields.12345.is_set=true`. To match an exact value for an enum custom field, use the gid of the desired enum option and not the name of the enum option: `custom_fields.12345.value=67890`.  **Not Supported**: searching for multiple exact matches of a custom field, searching for multi-enum custom field  *Note: If you specify `projects.any` and `sections.any`, you will receive tasks for the project **and** tasks for the section. If you're looking for only tasks in a section, omit the `projects.any` from the request.*  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tasks_for_workspace_with_http_info(workspace_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
        :param str text: Performs full-text search on both task name and description
        :param str resource_subtype: Filters results by the task's resource_subtype
        :param str assignee_any: Comma-separated list of user identifiers
        :param str assignee_not: Comma-separated list of user identifiers
        :param str portfolios_any: Comma-separated list of portfolio IDs
        :param str projects_any: Comma-separated list of project IDs
        :param str projects_not: Comma-separated list of project IDs
        :param str projects_all: Comma-separated list of project IDs
        :param str sections_any: Comma-separated list of section or column IDs
        :param str sections_not: Comma-separated list of section or column IDs
        :param str sections_all: Comma-separated list of section or column IDs
        :param str tags_any: Comma-separated list of tag IDs
        :param str tags_not: Comma-separated list of tag IDs
        :param str tags_all: Comma-separated list of tag IDs
        :param str teams_any: Comma-separated list of team IDs
        :param str followers_not: Comma-separated list of user identifiers
        :param str created_by_any: Comma-separated list of user identifiers
        :param str created_by_not: Comma-separated list of user identifiers
        :param str assigned_by_any: Comma-separated list of user identifiers
        :param str assigned_by_not: Comma-separated list of user identifiers
        :param str liked_by_not: Comma-separated list of user identifiers
        :param str commented_on_by_not: Comma-separated list of user identifiers
        :param date due_on_before: ISO 8601 date string
        :param date due_on_after: ISO 8601 date string
        :param date due_on: ISO 8601 date string or `null`
        :param datetime due_at_before: ISO 8601 datetime string
        :param datetime due_at_after: ISO 8601 datetime string
        :param date start_on_before: ISO 8601 date string
        :param date start_on_after: ISO 8601 date string
        :param date start_on: ISO 8601 date string or `null`
        :param date created_on_before: ISO 8601 date string
        :param date created_on_after: ISO 8601 date string
        :param date created_on: ISO 8601 date string or `null`
        :param datetime created_at_before: ISO 8601 datetime string
        :param datetime created_at_after: ISO 8601 datetime string
        :param date completed_on_before: ISO 8601 date string
        :param date completed_on_after: ISO 8601 date string
        :param date completed_on: ISO 8601 date string or `null`
        :param datetime completed_at_before: ISO 8601 datetime string
        :param datetime completed_at_after: ISO 8601 datetime string
        :param date modified_on_before: ISO 8601 date string
        :param date modified_on_after: ISO 8601 date string
        :param date modified_on: ISO 8601 date string or `null`
        :param datetime modified_at_before: ISO 8601 datetime string
        :param datetime modified_at_after: ISO 8601 datetime string
        :param bool is_blocking: Filter to incomplete tasks with dependents
        :param bool is_blocked: Filter to tasks with incomplete dependencies
        :param bool has_attachment: Filter to tasks with attachments
        :param bool completed: Filter to completed tasks
        :param bool is_subtask: Filter to subtasks
        :param str sort_by: One of `due_date`, `created_at`, `completed_at`, `likes`, or `modified_at`, defaults to `modified_at`
        :param bool sort_ascending: Default `false`
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseArray
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workspace_gid', 'text', 'resource_subtype', 'assignee_any', 'assignee_not', 'portfolios_any', 'projects_any', 'projects_not', 'projects_all', 'sections_any', 'sections_not', 'sections_all', 'tags_any', 'tags_not', 'tags_all', 'teams_any', 'followers_not', 'created_by_any', 'created_by_not', 'assigned_by_any', 'assigned_by_not', 'liked_by_not', 'commented_on_by_not', 'due_on_before', 'due_on_after', 'due_on', 'due_at_before', 'due_at_after', 'start_on_before', 'start_on_after', 'start_on', 'created_on_before', 'created_on_after', 'created_on', 'created_at_before', 'created_at_after', 'completed_on_before', 'completed_on_after', 'completed_on', 'completed_at_before', 'completed_at_after', 'modified_on_before', 'modified_on_after', 'modified_on', 'modified_at_before', 'modified_at_after', 'is_blocking', 'is_blocked', 'has_attachment', 'completed', 'is_subtask', 'sort_by', 'sort_ascending', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        custom_fields_query_param_keys = []
        for key, val in six.iteritems(params['kwargs']):
            # Do not throw an error if the user provides custom field query parameters
            if re.match('^custom_fields_(.*?)_value$', key) or re.match('^custom_fields.(.*?).value$', key):
                params[key] = val
                continue
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_tasks_for_workspace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workspace_gid' is set
        if ('workspace_gid' not in params or
                params['workspace_gid'] is None):
            raise ValueError("Missing the required parameter `workspace_gid` when calling `search_tasks_for_workspace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workspace_gid' in params:
            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501

        query_params = []
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'resource_subtype' in params:
            query_params.append(('resource_subtype', params['resource_subtype']))  # noqa: E501
        if 'assignee_any' in params:
            query_params.append(('assignee.any', params['assignee_any']))  # noqa: E501
        if 'assignee_not' in params:
            query_params.append(('assignee.not', params['assignee_not']))  # noqa: E501
        if 'portfolios_any' in params:
            query_params.append(('portfolios.any', params['portfolios_any']))  # noqa: E501
        if 'projects_any' in params:
            query_params.append(('projects.any', params['projects_any']))  # noqa: E501
        if 'projects_not' in params:
            query_params.append(('projects.not', params['projects_not']))  # noqa: E501
        if 'projects_all' in params:
            query_params.append(('projects.all', params['projects_all']))  # noqa: E501
        if 'sections_any' in params:
            query_params.append(('sections.any', params['sections_any']))  # noqa: E501
        if 'sections_not' in params:
            query_params.append(('sections.not', params['sections_not']))  # noqa: E501
        if 'sections_all' in params:
            query_params.append(('sections.all', params['sections_all']))  # noqa: E501
        if 'tags_any' in params:
            query_params.append(('tags.any', params['tags_any']))  # noqa: E501
        if 'tags_not' in params:
            query_params.append(('tags.not', params['tags_not']))  # noqa: E501
        if 'tags_all' in params:
            query_params.append(('tags.all', params['tags_all']))  # noqa: E501
        if 'teams_any' in params:
            query_params.append(('teams.any', params['teams_any']))  # noqa: E501
        if 'followers_not' in params:
            query_params.append(('followers.not', params['followers_not']))  # noqa: E501
        if 'created_by_any' in params:
            query_params.append(('created_by.any', params['created_by_any']))  # noqa: E501
        if 'created_by_not' in params:
            query_params.append(('created_by.not', params['created_by_not']))  # noqa: E501
        if 'assigned_by_any' in params:
            query_params.append(('assigned_by.any', params['assigned_by_any']))  # noqa: E501
        if 'assigned_by_not' in params:
            query_params.append(('assigned_by.not', params['assigned_by_not']))  # noqa: E501
        if 'liked_by_not' in params:
            query_params.append(('liked_by.not', params['liked_by_not']))  # noqa: E501
        if 'commented_on_by_not' in params:
            query_params.append(('commented_on_by.not', params['commented_on_by_not']))  # noqa: E501
        if 'due_on_before' in params:
            query_params.append(('due_on.before', params['due_on_before']))  # noqa: E501
        if 'due_on_after' in params:
            query_params.append(('due_on.after', params['due_on_after']))  # noqa: E501
        if 'due_on' in params:
            query_params.append(('due_on', params['due_on']))  # noqa: E501
        if 'due_at_before' in params:
            query_params.append(('due_at.before', params['due_at_before']))  # noqa: E501
        if 'due_at_after' in params:
            query_params.append(('due_at.after', params['due_at_after']))  # noqa: E501
        if 'start_on_before' in params:
            query_params.append(('start_on.before', params['start_on_before']))  # noqa: E501
        if 'start_on_after' in params:
            query_params.append(('start_on.after', params['start_on_after']))  # noqa: E501
        if 'start_on' in params:
            query_params.append(('start_on', params['start_on']))  # noqa: E501
        if 'created_on_before' in params:
            query_params.append(('created_on.before', params['created_on_before']))  # noqa: E501
        if 'created_on_after' in params:
            query_params.append(('created_on.after', params['created_on_after']))  # noqa: E501
        if 'created_on' in params:
            query_params.append(('created_on', params['created_on']))  # noqa: E501
        if 'created_at_before' in params:
            query_params.append(('created_at.before', params['created_at_before']))  # noqa: E501
        if 'created_at_after' in params:
            query_params.append(('created_at.after', params['created_at_after']))  # noqa: E501
        if 'completed_on_before' in params:
            query_params.append(('completed_on.before', params['completed_on_before']))  # noqa: E501
        if 'completed_on_after' in params:
            query_params.append(('completed_on.after', params['completed_on_after']))  # noqa: E501
        if 'completed_on' in params:
            query_params.append(('completed_on', params['completed_on']))  # noqa: E501
        if 'completed_at_before' in params:
            query_params.append(('completed_at.before', params['completed_at_before']))  # noqa: E501
        if 'completed_at_after' in params:
            query_params.append(('completed_at.after', params['completed_at_after']))  # noqa: E501
        if 'modified_on_before' in params:
            query_params.append(('modified_on.before', params['modified_on_before']))  # noqa: E501
        if 'modified_on_after' in params:
            query_params.append(('modified_on.after', params['modified_on_after']))  # noqa: E501
        if 'modified_on' in params:
            query_params.append(('modified_on', params['modified_on']))  # noqa: E501
        if 'modified_at_before' in params:
            query_params.append(('modified_at.before', params['modified_at_before']))  # noqa: E501
        if 'modified_at_after' in params:
            query_params.append(('modified_at.after', params['modified_at_after']))  # noqa: E501
        if 'is_blocking' in params:
            query_params.append(('is_blocking', params['is_blocking']))  # noqa: E501
        if 'is_blocked' in params:
            query_params.append(('is_blocked', params['is_blocked']))  # noqa: E501
        if 'has_attachment' in params:
            query_params.append(('has_attachment', params['has_attachment']))  # noqa: E501
        if 'completed' in params:
            query_params.append(('completed', params['completed']))  # noqa: E501
        if 'is_subtask' in params:
            query_params.append(('is_subtask', params['is_subtask']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501

        # Checks if the user provided custom field query parameters and adds it to the request
        for key in custom_fields_query_param_keys:
            # If user provided in format: custom_fields.<CUSTOM_FIELD_GID>.value
            if re.match('^custom_fields.(.*?).value$', key):
                query_params.append((key, params[key]))  # noqa: E501
            # If user provided in format: custom_fields_<CUSTOM_FIELD_GID>_value
            elif re.match('^custom_fields_(.*?)_value$', key):
                removed_prefix = key.replace('custom_fields_', '')
                custom_fields_gid = removed_prefix.replace('_value', '')
                custom_fields_query_param_name = f'custom_fields.{custom_fields_gid}.value'
                query_params.append((custom_fields_query_param_name, params[key]))  # noqa: E501

        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/workspaces/{workspace_gid}/tasks/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseArray',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_parent_for_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Set the parent of a task  # noqa: E501

        parent, or no parent task at all. Returns an empty data block. When using `insert_before` and `insert_after`, at most one of those two options can be specified, and they must already be subtasks of the parent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_parent_for_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidSetParentBody body: The new parent of the subtask. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.set_parent_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.set_parent_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def set_parent_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Set the parent of a task  # noqa: E501

        parent, or no parent task at all. Returns an empty data block. When using `insert_before` and `insert_after`, at most one of those two options can be specified, and they must already be subtasks of the parent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_parent_for_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TaskGidSetParentBody body: The new parent of the subtask. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_parent_for_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_parent_for_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `set_parent_for_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}/setParent', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task(self, body, task_gid, **kwargs):  # noqa: E501
        """Update a task  # noqa: E501

        A specific, existing task can be updated by making a PUT request on the URL for that task. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated task record.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TasksTaskGidBody body: The task to update. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
        if kwargs.get('async_req'):
            return self.update_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
            return data

    def update_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
        """Update a task  # noqa: E501

        A specific, existing task can be updated by making a PUT request on the URL for that task. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated task record.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_with_http_info(body, task_gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TasksTaskGidBody body: The task to update. (required)
        :param str task_gid: The task to operate on. (required)
        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
        :return: TaskResponseData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('header_params')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_task`")  # noqa: E501
        # verify the required parameter 'task_gid' is set
        if ('task_gid' not in params or
                params['task_gid'] is None):
            raise ValueError("Missing the required parameter `task_gid` when calling `update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_gid' in params:
            path_params['task_gid'] = params['task_gid']  # noqa: E501

        query_params = []
        if 'opt_fields' in params:
            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
            collection_formats['opt_fields'] = 'csv'  # noqa: E501


        header_params = kwargs.get("header_params", {})

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json; charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json; charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/tasks/{task_gid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TaskResponseData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
